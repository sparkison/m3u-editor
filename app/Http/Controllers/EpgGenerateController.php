<?php

namespace App\Http\Controllers;

use App\Enums\ChannelLogoType;
use App\Enums\PlaylistChannelId;
use App\Facades\PlaylistFacade;
use App\Models\CustomPlaylist;
use App\Models\Epg;
use App\Models\MergedPlaylist;
use App\Models\Playlist;
use App\Models\PlaylistAlias;
use App\Services\EpgCacheService;
use Carbon\Carbon;
use DOMDocument;
use Exception;
use Filament\Notifications\Notification;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use XMLReader;

class EpgGenerateController extends Controller
{
    /**
     * File cache configuration
     */
    private const CACHE_TTL_HOURS = 6; // Cache files for 6 hours

    /**
     * Generate the EPG XML file
     *
     * @return Response
     */
    public function __invoke(string $uuid)
    {
        // Fetch the playlist
        $playlist = PlaylistFacade::resolvePlaylistByUuid($uuid);
        if (! $playlist) {
            return response()->json(['Error' => 'Playlist Not Found'], 404);
        }

        // Check if we have a valid cached file
        if ($this->isCacheValid($playlist, false)) {
            return $this->serveCachedFile($playlist, false);
        }

        // Generate and cache new file
        return $this->generateAndCache($playlist, false);
    }

    /**
     * Generate the EPG XML file and compress it
     *
     * @return Response
     */
    public function compressed(string $uuid)
    {
        // Fetch the playlist
        $playlist = PlaylistFacade::resolvePlaylistByUuid($uuid);
        if (! $playlist) {
            return response()->json(['Error' => 'Playlist Not Found'], 404);
        }

        // Check if we have a valid cached file
        if ($this->isCacheValid($playlist, true)) {
            return $this->serveCachedFile($playlist, true);
        }

        // Generate and cache new file
        return $this->generateAndCache($playlist, true);
    }

    /**
     * Generate the EPG XML file contents
     *
     * @param  Playlist|MergedPlaylist|CustomPlaylist|PlaylistAlias  $playlist
     */
    private function generate($playlist)
    {
        // Output the XML header
        echo '<?xml version="1.0" encoding="utf-8" ?><!DOCTYPE tv SYSTEM "xmltv.dtd">
<tv generator-info-name="Generated by m3u editor" generator-info-url="'.url('').'">';
        echo PHP_EOL;

        // Set up the channels
        $epgChannels = [];
        $dummyEpgChannels = [];
        $channels = PlaylistGenerateController::getChannelQuery($playlist);

        // Get playlist settings
        $channelNumber = $playlist->auto_channel_increment ? $playlist->channel_start - 1 : 0;
        $idChannelBy = $playlist->id_channel_by;
        $dummyEpgEnabled = $playlist->dummy_epg;
        $dummyEpgLength = (int) ($playlist->dummy_epg_length ?? 120); // Default to 120 minutes if not set
        $proxyEnabled = $playlist->enable_proxy;
        $logoProxyEnabled = $playlist->enable_logo_proxy;

        // Generate `<channel>` tags for each channel
        foreach ($channels->cursor() as $channel) {
            // Get/set the channel number
            $channelNo = $channel->channel;
            if (! $channelNo && ($playlist->auto_channel_increment || $idChannelBy === PlaylistChannelId::ChannelId)) {
                $channelNo = ++$channelNumber;
            }

            // Get the `tvg-id` based on the playlist setting
            switch ($idChannelBy) {
                case PlaylistChannelId::ChannelId:
                    $tvgId = $channel->source_id ?? $channel->id;
                    break;
                case PlaylistChannelId::Name:
                    $tvgId = $channel->name_custom ?? $channel->name;
                    break;
                case PlaylistChannelId::Title:
                    $tvgId = $channel->title_custom ?? $channel->title;
                    break;
                default:
                    $tvgId = $channel->stream_id_custom ?? $channel->stream_id;
                    break;
            }

            // If no TVG ID still, fallback to the channel source ID or internal ID as a last resort
            if (empty($tvgId)) {
                $tvgId = $channel->source_id ?? $channel->id;
            }

            // Make sure TVG ID only contains characters and numbers
            $tvgId = preg_replace(config('dev.tvgid.regex'), '', $tvgId);

            // Output the <channel> tag
            $title = $channel->title_custom ?? $channel->title;
            $title = htmlspecialchars($title);

            // Get the EPG channel data
            $epgData = $channel->epgChannel ?? null;

            // Output the <channel> tag
            if ($epgData) {
                // Keep track of which EPGs have which channels mapped
                // Need this to output the <programme> tags later
                if (! array_key_exists($epgData->epg_id, $epgChannels)) {
                    $epgChannels[$epgData->epg_id] = [];
                }
                $epgChannels[$epgData->epg_id][] = [$epgData->channel_id => $tvgId];

                // Get the icon
                $icon = '';
                if ($channel->logo) {
                    // Logo override takes precedence
                    $icon = $channel->logo;
                } elseif ($channel->logo_type === ChannelLogoType::Epg) {
                    $icon = $epgData->icon ?? '';
                } elseif ($channel->logo_type === ChannelLogoType::Channel) {
                    $icon = $channel->logo ?? $channel->logo_internal ?? '';
                }
                if (empty($icon)) {
                    $icon = url('/placeholder.png');
                }
                if ($logoProxyEnabled) {
                    $icon = LogoProxyController::generateProxyUrl($icon);
                }

                // Output the <channel> tag
                echo '  <channel id="'.$tvgId.'">'.PHP_EOL;
                echo '    <display-name lang="'.$epgData->lang.'">'.$title.'</display-name>';
                if ($channelNo !== null) {
                    echo '    <display-name>'.$channelNo.'</display-name>';
                }
                if ($icon) {
                    echo PHP_EOL.'    <icon src="'.htmlspecialchars($icon).'"/>';
                }
                echo PHP_EOL.'  </channel>'.PHP_EOL;
            } elseif ($dummyEpgEnabled) {
                // Get the icon
                $icon = $channel->logo ?? $channel->logo_internal ?? '';
                if (empty($icon)) {
                    $icon = url('/placeholder.png');
                }
                $icon = htmlspecialchars($icon);
                if ($logoProxyEnabled) {
                    $icon = LogoProxyController::generateProxyUrl($icon);
                }

                // Keep track of which channels need a dummy EPG program
                // Need this to output the <programme> tags later
                $dummyEpgChannels[] = [
                    'tvg_id' => $tvgId,
                    'channel_id' => $channel->id,
                    'channel_no' => $channelNo,
                    'title' => $title,
                    'icon' => $icon,
                    'group' => $channel->group ?? $channel->group_internal,
                    'include_category' => $playlist->dummy_epg_category,
                ];

                // Output the <channel> tag
                echo '  <channel id="'.$tvgId.'">'.PHP_EOL;
                echo '    <display-name>'.$title.'</display-name>';
                if ($channelNo !== null) {
                    echo PHP_EOL.'    <display-name>'.$channelNo.'</display-name>';
                }
                if ($icon) {
                    echo PHP_EOL.'    <icon src="'.$icon.'"/>';
                }
                echo PHP_EOL.'  </channel>'.PHP_EOL;
            }
        }

        // If networks are included, output their channel tags
        $networkChannels = [];
        if ($playlist->include_networks_in_m3u) {
            $networks = \App\Models\Network::where('user_id', $playlist->user_id)
                ->where('enabled', true)
                ->with('programmes')
                ->orderBy('channel_number')
                ->orderBy('name')
                ->get();

            foreach ($networks as $network) {
                $tvgId = 'network-'.$network->id;
                $title = htmlspecialchars($network->name, ENT_XML1);
                $icon = $network->logo ?? url('/placeholder.png');
                if ($logoProxyEnabled) {
                    $icon = LogoProxyController::generateProxyUrl($icon);
                }
                $channelNo = $network->channel_number;

                // Store for programme output later
                $networkChannels[] = $network;

                // Output the <channel> tag
                echo '  <channel id="'.$tvgId.'">'.PHP_EOL;
                echo '    <display-name>'.$title.'</display-name>';
                if ($channelNo !== null) {
                    echo PHP_EOL.'    <display-name>'.$channelNo.'</display-name>';
                }
                if ($icon) {
                    echo PHP_EOL.'    <icon src="'.htmlspecialchars($icon, ENT_XML1).'"/>';
                }
                echo PHP_EOL.'  </channel>'.PHP_EOL;
            }
        }

        // Fetch the EPGs (channels are keyed by EPG ID)
        $epgs = Epg::whereIn('id', array_keys($epgChannels))
            ->get();

        // Initialize cache service
        $cacheService = new EpgCacheService;

        // Loop through the EPGs and output the <programme> tags
        foreach ($epgs as $epg) {
            // Channel data
            $channels = $epgChannels[$epg->id];

            // Skip if no channels
            if (! count($channels)) {
                continue;
            }

            try {
                // Try to use cached data first with proper validation
                // CRITICAL: Check both is_cached flag AND that cache is actually valid
                // This prevents race condition where cache is being regenerated
                if ($epg->is_cached && $cacheService->isCacheValid($epg)) {
                    // Get all programmes from cache
                    $startDate = Carbon::now()->subDays(1)->format('Y-m-d');
                    $epgDays = config('dev.default_epg_days', 7);
                    $epgDays = is_numeric($epgDays) && $epgDays > 0 ? (int) $epgDays : 7;
                    $endDate = Carbon::now()
                        ->addDays($epgDays)
                        ->format('Y-m-d');

                    // Get all channel IDs that this EPG should map to
                    $epgChannelIds = [];
                    foreach ($channels as $channelMapping) {
                        $epgChannelIds = array_merge($epgChannelIds, array_keys($channelMapping));
                    }

                    // Get programmes from cache for date range
                    $cachedProgrammes = $cacheService->getCachedProgrammesRange($epg, $startDate, $endDate, $epgChannelIds);

                    // Pre-build channel mapping index for O(1) lookups
                    $channelMapping = [];
                    foreach ($channels as $channelMap) {
                        foreach ($channelMap as $epgChannelId => $mappedId) {
                            if (! isset($channelMapping[$epgChannelId])) {
                                $channelMapping[$epgChannelId] = [];
                            }
                            $channelMapping[$epgChannelId][] = $mappedId;
                        }
                    }

                    // Output programmes from cache
                    foreach ($cachedProgrammes as $channelId => $programmes) {
                        // Skip if no mapping for this channel
                        if (! isset($channelMapping[$channelId])) {
                            continue;
                        }

                        foreach ($programmes as $programme) {
                            // Format times once per programme (not per channel mapping)
                            $start = $this->formatXmltvDateTime($programme['start']);
                            $stop = $this->formatXmltvDateTime($programme['stop']);

                            foreach ($channelMapping[$channelId] as $mappedChannelId) {
                                // Build programme XML in buffer for batch output
                                $progXml = '  <programme channel="'.htmlspecialchars($mappedChannelId).'"';
                                if ($start) {
                                    $progXml .= ' start="'.$start.'"';
                                }
                                if ($stop) {
                                    $progXml .= ' stop="'.$stop.'"';
                                }
                                $progXml .= '>'.PHP_EOL;

                                if ($programme['title']) {
                                    $progXml .= '    <title>'.htmlspecialchars($programme['title']).'</title>'.PHP_EOL;
                                }
                                if ($programme['subtitle']) {
                                    $progXml .= '    <sub-title>'.htmlspecialchars($programme['subtitle']).'</sub-title>'.PHP_EOL;
                                }
                                if ($programme['desc']) {
                                    $progXml .= '    <desc>'.htmlspecialchars($programme['desc']).'</desc>'.PHP_EOL;
                                }
                                if ($programme['category']) {
                                    $progXml .= '    <category>'.htmlspecialchars($programme['category']).'</category>'.PHP_EOL;
                                }
                                if ($programme['episode_num']) {
                                    $progXml .= '    <episode-num system="xmltv_ns">'.htmlspecialchars($programme['episode_num']).'</episode-num>'.PHP_EOL;
                                }
                                if ($programme['icon']) {
                                    $icon = htmlspecialchars($programme['icon']);
                                    if ($logoProxyEnabled) {
                                        $icon = LogoProxyController::generateProxyUrl($icon);
                                    }
                                    $progXml .= '    <icon src="'.$icon.'"/>'.PHP_EOL;
                                }
                                // Program artwork images (NEW)
                                if (! empty($programme['images'] ?? null) && is_array($programme['images'])) {
                                    foreach ($programme['images'] as $image) {
                                        $rawUrl = htmlspecialchars($image['url'] ?? '');
                                        $proxiedUrl = $logoProxyEnabled && $rawUrl
                                            ? LogoProxyController::generateProxyUrl($rawUrl)
                                            : $rawUrl;

                                        $url = $proxiedUrl;
                                        $type = htmlspecialchars($image['type'], ENT_XML1);
                                        $width = htmlspecialchars($image['width'], ENT_XML1);
                                        $height = htmlspecialchars($image['height'], ENT_XML1);
                                        $orient = htmlspecialchars($image['orient'], ENT_XML1);
                                        $size = htmlspecialchars($image['size'], ENT_XML1);

                                        $progXml .= "    <icon src=\"{$url}\" type=\"{$type}\" width=\"{$width}\" height=\"{$height}\" orient=\"{$orient}\" size=\"{$size}\" />\n";
                                    }
                                }
                                if ($programme['rating']) {
                                    $progXml .= '    <rating><value>'.htmlspecialchars($programme['rating']).'</value></rating>'.PHP_EOL;
                                }
                                if (! empty($programme['new']) && $programme['new']) {
                                    $progXml .= '    <new />'.PHP_EOL;
                                }

                                $progXml .= '  </programme>'.PHP_EOL;
                                echo $progXml;
                            }
                        }
                    }
                } else {
                    // Fallback to original XML reading if cache is not available
                    $this->processEpgWithXmlReader($epg, $channels, $playlist);
                }
            } catch (Exception $e) {
                // If cache fails, fallback to original XML reading
                $this->processEpgWithXmlReader($epg, $channels, $playlist);
            }
        }

        // If dummy EPG channels, generate dummy programmes
        if (count($dummyEpgChannels) > 0) {
            // Pre-calculate all time slots once (major optimization)
            $timeSlots = [];
            $startTime = Carbon::now()->startOf('day')->subMinutes($dummyEpgLength);
            $iterations = (int) ((5 * 24 * 60) / $dummyEpgLength);

            for ($i = 0; $i < $iterations; $i++) {
                $startTime->addMinutes($dummyEpgLength);
                $timeSlots[] = [
                    'start' => str_replace(':', '', $startTime->format('YmdHis P')),
                    'end' => str_replace(':', '', $startTime->copy()->addMinutes($dummyEpgLength)->format('YmdHis P')),
                ];
            }

            // Generate programmes for each channel using pre-calculated time slots
            foreach ($dummyEpgChannels as $dummyEpgChannel) {
                $tvgId = $dummyEpgChannel['tvg_id'];
                $title = $dummyEpgChannel['title'];
                $icon = $dummyEpgChannel['icon'];
                $group = $dummyEpgChannel['group'];
                $includeCategory = $dummyEpgChannel['include_category'];

                // Build all programmes for this channel in one string buffer
                $buffer = '';
                foreach ($timeSlots as $slot) {
                    $buffer .= '  <programme channel="'.$tvgId.'" start="'.$slot['start'].'" stop="'.$slot['end'].'">'.PHP_EOL;
                    $buffer .= '    <title>'.$title.'</title>'.PHP_EOL;
                    if ($icon) {
                        $buffer .= '    <icon src="'.$icon.'"/>'.PHP_EOL;
                    }
                    $buffer .= '    <desc>'.$title.'</desc>'.PHP_EOL;
                    if ($includeCategory) {
                        $buffer .= '    <category lang="en">'.$group.'</category>'.PHP_EOL;
                    }
                    $buffer .= '  </programme>'.PHP_EOL;
                }
                // Single echo per channel instead of 600+ echoes
                echo $buffer;
            }
        }

        // Output Network programme schedules
        if (! empty($networkChannels)) {
            foreach ($networkChannels as $network) {
                $tvgId = 'network-'.$network->id;

                // Get programmes that haven't ended yet
                $programmes = $network->programmes()
                    ->where('end_time', '>', Carbon::now()->subDay())
                    ->orderBy('start_time')
                    ->get();

                foreach ($programmes as $programme) {
                    $start = str_replace(':', '', $programme->start_time->format('YmdHis O'));
                    $stop = str_replace(':', '', $programme->end_time->format('YmdHis O'));
                    $title = htmlspecialchars($programme->title, ENT_XML1);
                    $desc = $programme->description ? htmlspecialchars($programme->description, ENT_XML1) : '';
                    $icon = $programme->image ? htmlspecialchars($programme->image, ENT_XML1) : '';
                    $category = $programme->contentable_type === 'App\\Models\\Episode' ? 'Series' : 'Movie';

                    echo '  <programme channel="'.$tvgId.'" start="'.$start.'" stop="'.$stop.'">'.PHP_EOL;
                    echo '    <title>'.$title.'</title>'.PHP_EOL;
                    if ($desc) {
                        echo '    <desc>'.$desc.'</desc>'.PHP_EOL;
                    }
                    if ($icon) {
                        echo '    <icon src="'.$icon.'"/>'.PHP_EOL;
                    }
                    echo '    <category>'.$category.'</category>'.PHP_EOL;
                    echo '  </programme>'.PHP_EOL;
                }
            }
        }

        // Close it out
        echo '</tv>';
    }

    /**
     * Check if cache file is valid and not expired
     */
    private function isCacheValid($playlist, bool $compressed = false): bool
    {
        $cacheFilePath = EpgCacheService::getPlaylistEpgCachePath($playlist, $compressed);
        $disk = Storage::disk('local');

        if (! $disk->exists($cacheFilePath)) {
            return false;
        }

        // Check if file is older than TTL
        $cacheFileTime = $disk->lastModified($cacheFilePath);
        $expiryTime = now()->subHours(self::CACHE_TTL_HOURS)->timestamp;

        return $cacheFileTime >= $expiryTime;
    }

    /**
     * Serve cached file directly
     */
    private function serveCachedFile($playlist, bool $compressed = false)
    {
        $cacheFilePath = EpgCacheService::getPlaylistEpgCachePath($playlist, $compressed);
        $disk = Storage::disk('local');

        $filename = Str::slug($playlist->name).($compressed ? '.xml.gz' : '.xml');
        $contentType = $compressed ? 'application/gzip' : 'application/xml';

        return response()->stream(
            function () use ($disk, $cacheFilePath) {
                $stream = $disk->readStream($cacheFilePath);
                fpassthru($stream);
                fclose($stream);
            },
            200,
            [
                'Access-Control-Allow-Origin' => '*',
                'Content-Disposition' => "attachment; filename=\"$filename\"",
                'Content-Type' => $contentType,
                'X-EPG-Cache' => 'HIT',
            ]
        );
    }

    /**
     * Generate and cache EPG file
     */
    private function generateAndCache($playlist, bool $compressed = false)
    {
        $cacheFilePath = EpgCacheService::getPlaylistEpgCachePath($playlist, $compressed);
        $disk = Storage::disk('local');

        // Ensure cache directory exists
        $cacheDir = dirname($cacheFilePath);
        if (! $disk->exists($cacheDir)) {
            $disk->makeDirectory($cacheDir, 0755, true);
        }

        $filename = Str::slug($playlist->name).($compressed ? '.xml.gz' : '.xml');
        $contentType = $compressed ? 'application/gzip' : 'application/xml';

        if ($compressed) {
            // For compressed, keep existing behaviour (generate then compress)
            // NOTE: streaming gzip on-the-fly is more complex; keep as-is for safety
            ob_start();
            $this->generate($playlist);
            $content = ob_get_clean();
            $compressedContent = gzencode($content, 9);

            // Save to cache
            $disk->put($cacheFilePath, $compressedContent);

            return response($compressedContent, 200, [
                'Content-Type' => $contentType,
                'Content-Disposition' => "attachment; filename=\"$filename\"",
                'Access-Control-Allow-Origin' => '*',
                'X-EPG-Cache' => 'MISS',
            ]);
        }

        // For regular XML, stream generation directly to the client and write cache incrementally
        return response()->stream(function () use ($playlist, $disk, $cacheFilePath) {
            // Resolve full path for cache and ensure directory exists
            $fullPath = $disk->path($cacheFilePath);
            $dir = dirname($fullPath);
            if (! is_dir($dir)) {
                @mkdir($dir, 0755, true);
            }

            $tmpPath = $fullPath.'.tmp';
            $fh = null;
            $completed = false;

            // Register a shutdown handler to remove the temp file if generation did not complete
            $cleanupShutdown = function () use (&$completed, &$fh, $tmpPath, $dir) {
                try {
                    if (! $completed) {
                        if (is_resource($fh)) {
                            @fclose($fh);
                        }
                        if (file_exists($tmpPath)) {
                            @unlink($tmpPath);
                        }
                    }

                    // Also cleanup stale tmp files to avoid orphans
                    foreach (glob($dir.'/*.tmp') as $f) {
                        try {
                            @unlink($f);
                        } catch (\Throwable $e) {
                            // ignore
                        }
                    }
                } catch (\Throwable $e) {
                    // ignore shutdown cleanup errors
                }
            };
            register_shutdown_function($cleanupShutdown);

            $fh = @fopen($tmpPath, 'w');
            if ($fh === false) {
                // Fallback: if we can't write cache, just stream without caching
                $this->generate($playlist);

                return;
            }

            // Start an output buffer with a callback that writes each flushed chunk to cache
            ob_start(function ($buffer) use ($fh) {
                // Write chunk to cache file
                @fwrite($fh, $buffer);

                // Return buffer so it is sent to the client
                return $buffer;
            }, 4096);

            try {
                // Generate will echo directly; each echo will be passed through the ob callback
                $this->generate($playlist);

                // Mark completed only after successful generation
                $completed = true;

                // Flush any remaining buffers
                while (ob_get_level() > 0) {
                    ob_end_flush();
                }
            } finally {
                // Ensure file handle closed and atomically move temp to final path only on success
                if (is_resource($fh)) {
                    fclose($fh);
                }
                if ($completed) {
                    @rename($tmpPath, $fullPath);
                } else {
                    if (file_exists($tmpPath)) {
                        @unlink($tmpPath);
                    }
                }
            }
        }, 200, [
            'Access-Control-Allow-Origin' => '*',
            'Content-Disposition' => "attachment; filename=\"$filename\"",
            'Content-Type' => $contentType,
            'X-EPG-Cache' => 'MISS',
        ]);
    }

    /**
     * Gzip the file
     *
     * @param  string  $filename
     * @param  string  $disk
     * @param  bool  $delete_original
     * @return bool
     */
    private function gzip($filename, $disk = 'local', $delete_original = false)
    {
        $disk = Storage::disk($disk);
        $data = $disk->get($filename);
        $out_file = "$filename.gz";

        $gzdata = gzencode($data, 9);
        $disk->put($out_file, $gzdata);
        $fp = fopen($disk->path($out_file), 'w');
        $result = fwrite($fp, $gzdata);
        fclose($fp);

        if ($result && $delete_original) {
            $disk->delete($filename);
        }

        return $result > 0;
    }

    /**
     * Format datetime for XMLTV format
     *
     * @param  string  $datetime  ISO 8601 datetime string
     * @return string|null XMLTV formatted datetime
     */
    private function formatXmltvDateTime($datetime)
    {
        if (! $datetime) {
            return null;
        }

        try {
            $carbon = Carbon::parse($datetime);

            // Format as YYYYMMDDHHMMSS +ZZZZ
            return $carbon->format('YmdHis O');
        } catch (Exception $e) {
            return null;
        }
    }

    /**
     * Process EPG using XMLReader (fallback method)
     *
     * @param  Epg  $epg
     * @param  array  $channels
     * @param  mixed  $playlist
     */
    private function processEpgWithXmlReader($epg, $channels, $playlist)
    {
        // Get the content
        $filePath = null;
        if ($epg->url && str_starts_with($epg->url, 'http')) {
            $filePath = Storage::disk('local')->path($epg->file_path);
        } elseif ($epg->uploads && Storage::disk('local')->exists($epg->uploads)) {
            $filePath = Storage::disk('local')->path($epg->uploads);
        } elseif ($epg->url) {
            $filePath = $epg->url;
        }

        if (! $filePath) {
            // Send notification
            $error = 'Invalid EPG file. Unable to read or download an associated EPG file. Please check the URL or uploaded file and try again.';
            Notification::make()
                ->danger()
                ->title("Error generating epg data for playlist \"{$playlist->name}\" using EPG \"{$epg->name}\"")
                ->body($error)
                ->broadcast($epg->user);
            Notification::make()
                ->danger()
                ->title("Error generating epg data for playlist \"{$playlist->name}\" using EPG \"{$epg->name}\"")
                ->body($error)
                ->sendToDatabase($epg->user);

            return;
        }

        // Set up the reader
        $programReader = new XMLReader;
        $programReader->open('compress.zlib://'.$filePath);

        // Loop through the XML data
        while (@$programReader->read()) {
            // Only consider XML elements and programme nodes
            if ($programReader->nodeType == XMLReader::ELEMENT && $programReader->name === 'programme') {
                // Get the channel id
                $channelId = trim($programReader->getAttribute('channel'));
                if (! $channelId) {
                    continue;
                }

                // EPG could be applied to multiple channels, find all matching channels
                $filtered = array_filter($channels, fn ($ch) => array_key_exists($channelId, $ch));
                if (! count($filtered)) {
                    continue;
                }
                // Channel program found, output the <programme> tag
                // First, we need to make sure the channel is correct
                // Replace `channel="<channel_id>"` with `channel="<stream_id>"`
                $itemDom = new DOMDocument;
                $itemDom->loadXML($programReader->readOuterXML());

                // Get the item element
                $item = $itemDom->documentElement;
                foreach ($filtered as $ch) {
                    // Modify the channel attribute
                    $item->setAttribute('channel', $ch[$channelId]);

                    // Output modified line
                    echo '  '.$itemDom->saveXML($item).PHP_EOL;
                }
            }
        }
        // Close the XMLReader for this epg
        $programReader->close();
    }
}
